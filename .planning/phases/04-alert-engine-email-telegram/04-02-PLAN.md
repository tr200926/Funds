---
phase: 04-alert-engine-email-telegram
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - supabase/functions/evaluate-alerts/index.ts
  - supabase/functions/dispatch-notifications/index.ts
  - supabase/functions/escalate-alerts/index.ts
autonomous: true

user_setup:
  - service: resend
    why: "Email delivery for alert notifications"
    env_vars:
      - name: RESEND_API_KEY
        source: "Resend Dashboard (resend.com) -> API Keys -> Create API Key"
    dashboard_config:
      - task: "Verify sending domain (targetspro.com) or use test sender during development"
        location: "Resend Dashboard -> Domains -> Add Domain"
  - service: telegram
    why: "Telegram channel delivery for alert notifications"
    env_vars:
      - name: TELEGRAM_BOT_TOKEN
        source: "Telegram @BotFather -> /newbot -> copy token (format: 123456:ABC-DEF)"
    dashboard_config:
      - task: "Create bot via @BotFather, add bot to target group/channel, get chat_id"
        location: "Telegram app -> @BotFather for bot creation; use https://api.telegram.org/bot<token>/getUpdates to find chat_id after sending a message to the group"
  - service: supabase-vault
    why: "Store supabase_url and service_role_key in Vault for pg_net trigger access"
    env_vars: []
    dashboard_config:
      - task: "Create Vault secrets named 'supabase_url' and 'service_role_key' via SQL Editor"
        location: "Supabase Dashboard -> SQL Editor -> Run: SELECT vault.create_secret('<your-project-url>', 'supabase_url'); SELECT vault.create_secret('<your-service-role-key>', 'service_role_key');"

must_haves:
  truths:
    - "evaluate-alerts receives trigger payload, loads matching active rules, evaluates each, checks cooldown, creates alert rows, and fires dispatch-notifications"
    - "dispatch-notifications receives alert_id, loads eligible channels by severity, checks quiet hours (emergency bypasses), sends via Resend and Telegram, logs delivery status"
    - "escalate-alerts finds unacknowledged pending alerts past escalation timeout, promotes severity, re-dispatches notifications"
  artifacts:
    - path: "supabase/functions/evaluate-alerts/index.ts"
      provides: "Alert evaluation Edge Function triggered by pg_net"
      contains: "Deno.serve"
      min_lines: 60
    - path: "supabase/functions/dispatch-notifications/index.ts"
      provides: "Multi-channel notification dispatch Edge Function"
      contains: "Deno.serve"
      min_lines: 80
    - path: "supabase/functions/escalate-alerts/index.ts"
      provides: "Scheduled escalation checker Edge Function"
      contains: "Deno.serve"
      min_lines: 40
  key_links:
    - from: "supabase/functions/evaluate-alerts/index.ts"
      to: "supabase/functions/_shared/alert-evaluators.ts"
      via: "import evaluateRule"
      pattern: "import.*evaluateRule.*from.*_shared"
    - from: "supabase/functions/evaluate-alerts/index.ts"
      to: "supabase/functions/dispatch-notifications/index.ts"
      via: "fire-and-forget fetch to dispatch-notifications endpoint"
      pattern: "fetch.*dispatch-notifications"
    - from: "supabase/functions/dispatch-notifications/index.ts"
      to: "Resend API"
      via: "fetch POST to https://api.resend.com/emails"
      pattern: "api\\.resend\\.com/emails"
    - from: "supabase/functions/dispatch-notifications/index.ts"
      to: "Telegram Bot API"
      via: "fetch POST to https://api.telegram.org/bot"
      pattern: "api\\.telegram\\.org/bot"
    - from: "supabase/functions/escalate-alerts/index.ts"
      to: "supabase/functions/dispatch-notifications/index.ts"
      via: "fetch to dispatch-notifications for re-notification on escalation"
      pattern: "fetch.*dispatch-notifications"
---

<objective>
Implement the three Supabase Edge Functions that form the alert engine runtime: evaluate-alerts (rule evaluation on data arrival), dispatch-notifications (multi-channel delivery via Resend email and Telegram), and escalate-alerts (scheduled severity promotion for unacknowledged alerts).

Purpose: These are the core runtime components that make alerting work -- from trigger to evaluation to delivery to escalation. Without them, the database triggers and shared code from Plan 01 have nothing to invoke.
Output: Three deployable Edge Function entry points in supabase/functions/.
</objective>

<execution_context>
@C:/Users/hossa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hossa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-alert-engine-email-telegram/04-RESEARCH.md
@.planning/phases/04-alert-engine-email-telegram/04-01-SUMMARY.md
@supabase/functions/_shared/types.ts
@supabase/functions/_shared/constants.ts
@supabase/functions/_shared/supabase-client.ts
@supabase/functions/_shared/alert-evaluators.ts
@supabase/functions/_shared/notification-formatters.ts
@supabase/migrations/20260212200001_alert_engine_triggers.sql
@lib/database.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement evaluate-alerts Edge Function</name>
  <files>supabase/functions/evaluate-alerts/index.ts</files>
  <action>
Create the evaluate-alerts Edge Function that receives trigger payloads from pg_net and evaluates alert rules.

**Entry point:** `Deno.serve(async (req) => { ... })`

**Flow:**
1. Parse request body as TriggerPayload (import from ../_shared/types.ts)
2. Create admin Supabase client using createAdminClient() from ../_shared/supabase-client.ts
3. Load active alert rules for the org: query alert_rules where org_id matches, is_active=true, and (ad_account_id matches the payload's ad_account_id OR ad_account_id IS NULL for org-wide rules)
4. Load the ad_account row for the triggered account (need account_name, currency, current_balance, current_daily_spend, status, etc.)
5. If no rules or no account found, return 200 with { evaluated: 0 }
6. For each rule:
   a. Call evaluateRule(supabase, rule, account) from ../_shared/alert-evaluators.ts
   b. If not triggered, continue
   c. Check cooldown: call supabase.rpc('is_alert_in_cooldown', { p_ad_account_id, p_alert_rule_id: rule.id, p_cooldown_minutes: rule.cooldown_minutes })
   d. If in cooldown, continue
   e. Insert new alert row into alerts table with: org_id, ad_account_id, alert_rule_id, severity (from rule), title, message, context_data (from eval result)
   f. If alert created successfully, fire-and-forget fetch to dispatch-notifications: POST to `${Deno.env.get('SUPABASE_URL')}/functions/v1/dispatch-notifications` with { alert_id: alert.id } and Bearer auth. Do NOT await this fetch (fire-and-forget pattern per research anti-patterns).
7. Return 200 with { evaluated: rules.length, alerts_created: alertsCreated }

**For account_status_change rule type:** If payload.event === 'status_change', pass the full payload (including old_status, new_status) to the evaluator. The evaluator handles this case specially.

**Error handling:** Wrap the entire handler in try/catch. On error, return 500 with { error: error.message }. Do NOT let errors from one rule evaluation prevent evaluating other rules -- wrap the per-rule loop body in its own try/catch.

**Important:** NUMERIC columns (current_balance, current_daily_spend) are strings in the database types. The evaluators handle Number() conversion internally.
  </action>
  <verify>
- File exists at supabase/functions/evaluate-alerts/index.ts
- Contains Deno.serve entry point
- Imports from ../_shared/ (types, supabase-client, alert-evaluators)
- Queries alert_rules with is_active=true filter
- Calls evaluateRule for each rule
- Calls supabase.rpc('is_alert_in_cooldown') for cooldown check
- Inserts into alerts table on trigger
- Fires fetch to dispatch-notifications without await
- Returns JSON response with evaluated count
- Has try/catch error handling at both handler and per-rule level
  </verify>
  <done>
evaluate-alerts Edge Function receives trigger payloads, loads active rules, evaluates each against current account data, respects cooldown windows, creates alert rows, and fires dispatch-notifications asynchronously. Error in one rule does not block evaluation of other rules.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement dispatch-notifications Edge Function</name>
  <files>supabase/functions/dispatch-notifications/index.ts</files>
  <action>
Create the dispatch-notifications Edge Function that delivers alerts across configured channels.

**Entry point:** `Deno.serve(async (req) => { ... })`

**Flow:**
1. Parse request body: { alert_id: string }
2. Create admin Supabase client
3. Load the alert with joined data: query alerts table with id=alert_id, select alert + related alert_rules (via alert_rule_id) + related ad_accounts (via ad_account_id). Use `.select('*, alert_rules(*), ad_accounts(*)')`.
4. If alert not found, return 404
5. Load eligible notification channels: query notification_channels where org_id=alert.org_id, is_enabled=true
6. Define severity ordering: import SEVERITY_ORDER from ../_shared/constants.ts
7. For each channel:
   a. Check min_severity: if alert severity level < channel min_severity level, skip
   b. Check quiet hours using isInQuietHours from ../_shared/notification-formatters.ts:
      - If alert.severity === 'emergency', BYPASS quiet hours (R5.8)
      - Otherwise, if currently in quiet hours, create a delivery row with status='queued' and continue
   c. Dispatch based on channel.channel_type:
      - **'email'**: Call sendEmail() -- POST to https://api.resend.com/emails with:
        - from: 'Targetspro Alerts <alerts@targetspro.com>' (or use Resend test sender 'onboarding@resend.dev' if domain not verified)
        - to: channel.config.recipients (string array)
        - subject: `[${alert.severity.toUpperCase()}] ${alert.title}`
        - html: formatAlertEmailHtml(alert) from ../_shared/notification-formatters.ts
        - Auth: Bearer RESEND_API_KEY from Deno.env
      - **'telegram'**: Call sendTelegram() -- POST to `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage` with:
        - chat_id: channel.config.chat_id
        - text: formatAlertTelegramText(alert) from ../_shared/notification-formatters.ts
        - parse_mode: 'HTML'
   d. Create alert_deliveries row with: alert_id, channel_type, recipient (email address or chat_id), status ('sent' or 'failed'), response_data, error_message, sent_at (if sent)

**Helper functions** (defined within this file):
- `async sendEmail(alert, channel)`: Returns DeliveryResult. Uses fetch to Resend API.
- `async sendTelegram(alert, channel)`: Returns DeliveryResult. Uses fetch to Telegram Bot API.
- `getRecipient(channel)`: Returns string -- first email from recipients array for email channels, chat_id for telegram.

**Error handling:** Each channel dispatch is wrapped in try/catch. If email fails, telegram should still be attempted. Log all delivery attempts to alert_deliveries regardless of success/failure.

**Important:** Read RESEND_API_KEY and TELEGRAM_BOT_TOKEN from Deno.env.get(). These are set via `npx supabase secrets set` (not Vault -- Vault is for SQL-level access, Edge Function secrets are separate).
  </action>
  <verify>
- File exists at supabase/functions/dispatch-notifications/index.ts
- Contains Deno.serve entry point
- Loads alert with joined alert_rules and ad_accounts
- Filters channels by min_severity using SEVERITY_ORDER
- Emergency alerts bypass quiet hours check
- Sends email via fetch to api.resend.com/emails
- Sends telegram via fetch to api.telegram.org/bot
- Creates alert_deliveries rows for every dispatch attempt
- Uses Deno.env.get for RESEND_API_KEY and TELEGRAM_BOT_TOKEN
- Per-channel try/catch so one failure does not block other channels
  </verify>
  <done>
dispatch-notifications Edge Function loads alert details, filters eligible channels by severity, respects quiet hours (emergency bypasses), sends email via Resend HTTPS API and Telegram messages via Bot API, and logs every delivery attempt to alert_deliveries with status, response data, and error messages.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement escalate-alerts Edge Function</name>
  <files>supabase/functions/escalate-alerts/index.ts</files>
  <action>
Create the escalate-alerts Edge Function that promotes unacknowledged alerts to higher severity levels.

**Entry point:** `Deno.serve(async (req) => { ... })`

**Flow:**
1. Create admin Supabase client
2. Import ESCALATION_TIMEOUTS and SEVERITY_NEXT from ../_shared/constants.ts
3. For each severity level that can escalate (info, warning, critical -- NOT emergency):
   a. Calculate the cutoff time: now() minus ESCALATION_TIMEOUTS[severity] minutes
   b. Query alerts where: status='pending', severity=current_level, created_at < cutoff_time
   c. For each matching alert:
      - Determine next severity using SEVERITY_NEXT[severity]
      - If next severity is null (already at max), skip
      - Update the alert: SET severity=next_severity, context_data = context_data merged with { escalated_from: old_severity, escalated_at: now() }
      - Fire dispatch-notifications for this alert (to re-notify at higher severity): fetch to dispatch-notifications with { alert_id: alert.id }, Bearer auth, fire-and-forget (but DO await here since this is a batch job, not a hot path)
4. Return 200 with { escalated: count }

**Important:** Only escalate alerts with status='pending' (not acknowledged, resolved, or dismissed). Once a user acknowledges, escalation stops.

**Important:** The pg_cron job calls this every 15 minutes. It should be idempotent -- running it twice in a row should not double-escalate because the severity is already promoted on first run.

**Error handling:** Wrap in try/catch. Log errors but continue processing other alerts.
  </action>
  <verify>
- File exists at supabase/functions/escalate-alerts/index.ts
- Contains Deno.serve entry point
- Queries pending alerts older than escalation timeout per severity level
- Updates alert severity to next level using SEVERITY_NEXT mapping
- Merges escalation metadata into context_data
- Calls dispatch-notifications for re-notification
- Only processes status='pending' alerts
- Returns escalated count in response
  </verify>
  <done>
escalate-alerts Edge Function queries pending alerts past their severity-specific timeout, promotes severity (info->warning->critical->emergency), records escalation in context_data, and re-dispatches notifications at the new severity level. Acknowledged/resolved alerts are never escalated.
  </done>
</task>

</tasks>

<verification>
- All 3 Edge Function files use Deno.serve() pattern
- All import from ../_shared/ using relative Deno-compatible paths
- evaluate-alerts handles both spend/balance triggers and status change triggers
- dispatch-notifications supports both email and telegram channels
- escalate-alerts is idempotent and only processes pending alerts
- Fire-and-forget pattern used in evaluate-alerts (not awaited); awaited in escalate-alerts (batch job)
- Emergency alerts bypass quiet hours in dispatch-notifications
- All NUMERIC values converted from strings via Number() before comparison
</verification>

<success_criteria>
- Three Edge Function entry points exist and follow the Deno.serve pattern
- evaluate-alerts: trigger -> load rules -> evaluate -> cooldown check -> create alert -> dispatch
- dispatch-notifications: load alert -> filter channels -> check quiet hours -> send email/telegram -> log delivery
- escalate-alerts: find stale pending alerts -> promote severity -> re-dispatch
- No hardcoded credentials -- all from Deno.env.get()
</success_criteria>

<output>
After completion, create `.planning/phases/04-alert-engine-email-telegram/04-02-SUMMARY.md`
</output>
