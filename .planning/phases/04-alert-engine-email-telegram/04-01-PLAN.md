---
phase: 04-alert-engine-email-telegram
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260212200001_alert_engine_triggers.sql
  - supabase/functions/_shared/types.ts
  - supabase/functions/_shared/constants.ts
  - supabase/functions/_shared/supabase-client.ts
  - supabase/functions/_shared/alert-evaluators.ts
  - supabase/functions/_shared/notification-formatters.ts
autonomous: true

must_haves:
  truths:
    - "Database triggers invoke evaluate-alerts Edge Function on spend_records INSERT and balance_snapshots INSERT"
    - "Cooldown check prevents duplicate alerts within configurable window"
    - "Account status change trigger fires only when status column actually changes"
    - "Escalation cron job runs every 15 minutes via pg_cron"
    - "Shared Edge Function code provides typed evaluators for all 5 core rule types"
  artifacts:
    - path: "supabase/migrations/20260212200001_alert_engine_triggers.sql"
      provides: "pg_net triggers, cooldown RPC, status change trigger, pg_cron schedule, Vault secret references"
      contains: "net.http_post"
    - path: "supabase/functions/_shared/types.ts"
      provides: "Shared TypeScript types for alert engine Edge Functions"
      contains: "TriggerPayload"
    - path: "supabase/functions/_shared/constants.ts"
      provides: "Severity ordering, default values"
      contains: "SEVERITY_ORDER"
    - path: "supabase/functions/_shared/supabase-client.ts"
      provides: "Shared Supabase admin client factory for Edge Functions"
      contains: "createClient"
    - path: "supabase/functions/_shared/alert-evaluators.ts"
      provides: "Rule evaluation functions for balance_threshold, time_to_depletion, spend_spike, zero_spend, account_status_change"
      contains: "evaluateRule"
    - path: "supabase/functions/_shared/notification-formatters.ts"
      provides: "Email HTML and Telegram text formatters for alerts"
      contains: "formatAlertEmailHtml"
  key_links:
    - from: "supabase/migrations/20260212200001_alert_engine_triggers.sql"
      to: "supabase/functions/evaluate-alerts/index.ts"
      via: "pg_net HTTP POST from trigger to Edge Function"
      pattern: "net\\.http_post.*evaluate-alerts"
    - from: "supabase/functions/_shared/alert-evaluators.ts"
      to: "supabase RPC"
      via: "supabase.rpc calls for cooldown check and time-to-depletion"
      pattern: "supabase\\.rpc"
---

<objective>
Create the database infrastructure (pg_net triggers, cooldown RPC, pg_cron schedule, Vault references) and shared Edge Function code (types, evaluators, formatters) that form the foundation for the entire alert engine.

Purpose: All three Edge Functions (evaluate-alerts, dispatch-notifications, escalate-alerts) depend on shared types, evaluator logic, and the database triggers that invoke them. This plan builds everything they need.
Output: One SQL migration file with all trigger/RPC/cron definitions, plus the supabase/functions/_shared/ directory with 5 TypeScript modules.
</objective>

<execution_context>
@C:/Users/hossa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hossa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-alert-engine-email-telegram/04-RESEARCH.md
@supabase/migrations/20260212000001_create_core_schema.sql
@supabase/migrations/20260212000003_create_triggers.sql
@supabase/migrations/20260212000004_seed_initial_data.sql
@lib/database.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create alert engine database migration</name>
  <files>supabase/migrations/20260212200001_alert_engine_triggers.sql</files>
  <action>
Create a single SQL migration file that adds all database-level infrastructure for the alert engine. The migration must be wrapped in BEGIN/COMMIT and include:

**1. Enable pg_net extension:**
```sql
CREATE EXTENSION IF NOT EXISTS pg_net WITH SCHEMA extensions;
```

**2. Cooldown check RPC function** (`is_alert_in_cooldown`):
- Accepts: p_ad_account_id UUID, p_alert_rule_id UUID, p_cooldown_minutes INT
- Returns: BOOLEAN
- Logic: Check if any alert exists in the `alerts` table for the given ad_account_id + alert_rule_id combination where created_at is within the last p_cooldown_minutes minutes
- Must be SECURITY DEFINER with search_path = public

**3. Trigger function for alert evaluation** (`invoke_alert_evaluation`):
- SECURITY DEFINER, LANGUAGE plpgsql
- Reads `supabase_url` and `service_role_key` from `vault.decrypted_secrets`
- Calls `net.http_post()` to `{supabase_url}/functions/v1/evaluate-alerts`
- Sends JSON body with: table (TG_TABLE_NAME), record_id (NEW.id), ad_account_id (NEW.ad_account_id), org_id (NEW.org_id)
- Sets Authorization header with Bearer + service_role_key
- Timeout: 5000ms
- RETURNS NEW (does not block the INSERT)

**4. Attach triggers (AFTER INSERT only, not UPDATE):**
- `on_spend_record_evaluate_alerts` on spend_records AFTER INSERT
- `on_balance_snapshot_evaluate_alerts` on balance_snapshots AFTER INSERT
- Use DROP TRIGGER IF EXISTS before CREATE to be idempotent

**5. Account status change trigger** (`invoke_status_change_evaluation`):
- SECURITY DEFINER, LANGUAGE plpgsql
- Only fires when OLD.status IS DISTINCT FROM NEW.status
- Reads Vault secrets same as above
- Calls evaluate-alerts with body: table='ad_accounts', record_id=NEW.id, ad_account_id=NEW.id, org_id=NEW.org_id, event='status_change', old_status=OLD.status, new_status=NEW.status
- Attach as: `on_ad_account_status_change` AFTER UPDATE ON ad_accounts FOR EACH ROW WHEN (OLD.status IS DISTINCT FROM NEW.status)

**6. pg_cron schedule for escalation:**
- Use `SELECT cron.schedule(...)` to create a job named 'escalate-alerts-check' running every 15 minutes ('*/15 * * * *')
- The cron job body calls net.http_post to `{supabase_url}/functions/v1/escalate-alerts` with Bearer auth from Vault
- Body: '{"source": "pg_cron"}'::jsonb

**7. Comments on all new objects** for documentation.

**Important:** Do NOT store actual secret values in the migration. The migration references Vault secrets by name ('supabase_url' and 'service_role_key'). These must be populated separately via the Supabase Dashboard or `vault.create_secret()` calls. Add a comment block at the top explaining this prerequisite.

**Important:** The pg_net requests execute AFTER the transaction commits, so denormalization triggers (from Phase 1 migration 000003) will have already updated ad_accounts.current_* fields by the time the Edge Function runs. Document this in a code comment.
  </action>
  <verify>
Validate SQL syntax by checking the file parses correctly:
- File exists and is non-empty
- Contains CREATE EXTENSION for pg_net
- Contains CREATE OR REPLACE FUNCTION for is_alert_in_cooldown, invoke_alert_evaluation, invoke_status_change_evaluation
- Contains CREATE TRIGGER for on_spend_record_evaluate_alerts, on_balance_snapshot_evaluate_alerts, on_ad_account_status_change
- Contains cron.schedule call
- All functions use SECURITY DEFINER
- Triggers on spend_records are AFTER INSERT only (not AFTER INSERT OR UPDATE)
  </verify>
  <done>
SQL migration file exists with: pg_net extension, is_alert_in_cooldown RPC, 3 trigger functions, 3 triggers (spend INSERT, balance INSERT, status UPDATE), pg_cron escalation schedule. All functions use Vault for secrets. No hardcoded credentials.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create shared Edge Function modules</name>
  <files>
supabase/functions/_shared/types.ts
supabase/functions/_shared/constants.ts
supabase/functions/_shared/supabase-client.ts
supabase/functions/_shared/alert-evaluators.ts
supabase/functions/_shared/notification-formatters.ts
  </files>
  <action>
Create the `supabase/functions/_shared/` directory with 5 TypeScript modules used by all Edge Functions. These use Deno-style imports (ESM from esm.sh for Supabase client).

**types.ts:**
- TriggerPayload interface: { table: string, record_id: string, ad_account_id: string, org_id: string, event?: string, old_status?: string, new_status?: string }
- EvalResult interface: { triggered: boolean, title: string, message: string, context: Record<string, unknown> }
- AlertWithDetails type: alert row joined with alert_rules and ad_accounts (use the Row types from the schema: severity, title, message, context_data, plus nested ad_accounts with account_name, platform_id, currency, and alert_rules with rule_type, config)
- NotificationChannel type matching notification_channels Row but with typed config (recipients: string[] for email, chat_id: string for telegram) and typed active_hours ({ start: string, end: string, timezone: string } | null)
- DeliveryResult: { ok: boolean, data?: unknown, error?: string }
- Severity type: 'info' | 'warning' | 'critical' | 'emergency'

**constants.ts:**
- SEVERITY_ORDER: Record<Severity, number> = { info: 0, warning: 1, critical: 2, emergency: 3 }
- DEFAULT_COOLDOWN_MINUTES = 180
- ESCALATION_TIMEOUTS: Record<Severity, number> (minutes before escalation): { info: 240, warning: 120, critical: 60, emergency: 0 } (emergency never escalates further)
- SEVERITY_NEXT: Record<Severity, Severity | null> = { info: 'warning', warning: 'critical', critical: 'emergency', emergency: null }

**supabase-client.ts:**
- Export a `createAdminClient()` function that returns a Supabase client using `Deno.env.get('SUPABASE_URL')` and `Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')` -- these are auto-populated in Edge Functions
- Import createClient from 'https://esm.sh/@supabase/supabase-js@2'
- Configure with: auth: { autoRefreshToken: false, persistSession: false }

**alert-evaluators.ts:**
- Export async function `evaluateRule(supabase, rule, account): Promise<EvalResult>`
- Import types from ./types.ts
- Implement switch on rule.rule_type for 5 core types:
  - `balance_threshold`: Compare Number(account.current_balance) against config.threshold_value. Title: "Low Balance: {account_name}". Include balance, threshold, currency in context.
  - `time_to_depletion`: Call supabase.rpc('calculate_time_to_depletion', { p_ad_account_id, p_lookback_days }) if this RPC exists, otherwise calculate manually using last N days of spend_records. Compare days remaining against config.days_remaining threshold. Title: "Funds Depleting: {account_name}".
  - `spend_spike`: Query last config.lookback_days (default 7) spend_records, compute today's spend vs average of prior days. Trigger if percentage increase >= config.percentage_increase (default 50). Title: "Spend Spike: {account_name}".
  - `zero_spend`: Query last config.consecutive_days spend_records, check if all have daily_spend = 0. Title: "Zero Spend: {account_name}".
  - `account_status_change`: Check if the trigger payload includes event='status_change'. If so, triggered=true with old/new status in context. Title: "Status Changed: {account_name}". For non-status-change triggers, return triggered=false.
- NUMERIC columns are strings in TypeScript (per project decision), so use Number() to convert current_balance, daily_spend before comparison
- For spend_spike and zero_spend, query spend_records from supabase directly within the evaluator
- Default case returns triggered=false

**notification-formatters.ts:**
- Export `formatAlertEmailHtml(alert: AlertWithDetails): string` -- produces a clean HTML email with:
  - Severity badge (colored: info=blue, warning=yellow, critical=red, emergency=dark-red)
  - Alert title and message
  - Account name, platform, balance if available
  - Timestamp in Africa/Cairo timezone using Intl.DateTimeFormat
  - Link placeholder to dashboard alert page
- Export `formatAlertTelegramText(alert: AlertWithDetails): string` -- produces HTML-formatted text (Telegram parse_mode='HTML') with:
  - Severity emoji prefix (info=info-circle, warning=warning, critical=red-circle, emergency=siren)
  - Bold title, message body
  - Account name, platform, balance/days-remaining from context_data
  - Cairo timezone timestamp
- Export `isInQuietHours(activeHours: { start: string, end: string, timezone: string } | null): boolean`:
  - null activeHours = no quiet hours (24/7 delivery), return false
  - Compare current time in the specified timezone against start/end window
  - Handle midnight-wrapping windows (e.g., 22:00-06:00)
  - Use Intl.DateTimeFormat with timeZone option for timezone conversion
  </action>
  <verify>
Verify all 5 files exist and have correct structure:
- types.ts exports TriggerPayload, EvalResult, AlertWithDetails, NotificationChannel, DeliveryResult, Severity
- constants.ts exports SEVERITY_ORDER, DEFAULT_COOLDOWN_MINUTES, ESCALATION_TIMEOUTS, SEVERITY_NEXT
- supabase-client.ts exports createAdminClient that uses Deno.env
- alert-evaluators.ts exports evaluateRule with switch on 5 rule types
- notification-formatters.ts exports formatAlertEmailHtml, formatAlertTelegramText, isInQuietHours
- All imports use Deno-compatible paths (relative ./ for local, https://esm.sh/ for external)
- No npm-style imports (no bare 'package-name' imports)
  </verify>
  <done>
Five shared modules exist in supabase/functions/_shared/ providing: typed interfaces matching the existing schema, severity constants with escalation mapping, admin Supabase client factory, rule evaluators for all 5 core types, and notification formatters for Email HTML and Telegram text with quiet hours support.
  </done>
</task>

</tasks>

<verification>
- SQL migration file is syntactically valid and idempotent (uses DROP IF EXISTS before CREATE)
- All shared TypeScript modules use Deno-compatible import paths
- Evaluators handle NUMERIC-as-string conversion (per project decision #2)
- Quiet hours use Africa/Cairo timezone (per project decision #3)
- No hardcoded secrets anywhere -- Vault for SQL, Deno.env for Edge Functions
</verification>

<success_criteria>
- Database migration creates 3 trigger functions, 3 triggers, 1 RPC function, and 1 pg_cron job
- 5 shared TypeScript modules exist with correct exports
- All code references match the Phase 1 schema (table names, column names, types)
</success_criteria>

<output>
After completion, create `.planning/phases/04-alert-engine-email-telegram/04-01-SUMMARY.md`
</output>
